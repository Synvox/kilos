#![feature(prelude_import)]
#![no_std]
#![feature(plugin)]
#![feature(proc_macro)]
#![plugin(rocket_codegen)]
#[prelude_import]
use std::prelude::v1::*;
#[macro_use]
extern crate std as std;

#[macro_use]
extern crate diesel;
#[macro_use]
extern crate diesel_codegen;

extern crate maud;
extern crate rocket;
extern crate rocket_contrib;
extern crate dotenv;
extern crate r2d2;
extern crate r2d2_diesel;
extern crate uuid;

use rocket_contrib::UUID;
use maud::{html, Markup};
use diesel::prelude::*;
use uuid::Uuid;

mod db {






    // cargo watch -s 'kill $(lsof -t -i:8000 -sTCP:LISTEN) && clear && cargo run'
    use std::ops::Deref;
    use diesel::pg::PgConnection;
    use dotenv::dotenv;
    use r2d2;
    use r2d2::{Pool, PooledConnection};
    use r2d2_diesel::ConnectionManager;
    use std::env;
    use rocket::http::Status;
    use rocket::request::{self, FromRequest};
    use rocket::{Request, State, Outcome};
    pub type PgSqlPool = Pool<ConnectionManager<PgConnection>>;
    pub fn establish_connection() -> PgSqlPool {
        dotenv().ok();
        let database_url = env::var("DATABASE_URL").expect("DATABASE_URL must be set");
        let config = r2d2::Config::default();
        let manager = ConnectionManager::<PgConnection>::new(database_url);
        Pool::new(config, manager).expect("Failed to create database pool.")
    }
    pub struct PgSqlConn(PooledConnection<ConnectionManager<PgConnection>>);
    impl Deref for PgSqlConn {
        type Target = PgConnection;
        fn deref(&self) -> &Self::Target {
            &self.0
        }
    }
    impl<'a, 'r> FromRequest<'a, 'r> for PgSqlConn {
        type Error = ();
        fn from_request(request: &'a Request<'r>) -> request::Outcome<PgSqlConn, ()> {
            let pool = match <State<PgSqlPool> as FromRequest>::from_request(request) {
                Outcome::Success(pool) => pool,
                Outcome::Failure(e) => return Outcome::Failure(e),
                Outcome::Forward(_) => return Outcome::Forward(()),
            };
            match pool.get() {
                Ok(conn) => Outcome::Success(PgSqlConn(conn)),
                Err(_) => Outcome::Failure((Status::ServiceUnavailable, ())),
            }
        }
    }
}
mod schema {
    use models::Scope_roles;
    mod __diesel_infer_schema {
        #[infer_schema_options(database_url = "dotenv:DATABASE_URL")]
        struct _Dummy;
        mod infer_scope_permissions {
            #[infer_table_from_schema_options(database_url =
                                                  "postgres://ryan:@localhost:5432/rocket",
                                              table_name =
                                                  "scope_permissions")]
            struct __DieselInferTableFromSchema;
            #[doc = r" Representation of the `scope_permissions` table."]
            #[doc = r""]
            #[doc = r" (Automatically generated by Diesel.)"]
            pub mod scope_permissions {
                #![allow(dead_code)]
                use {QuerySource, Table, JoinTo};
                use associations::HasTable;
                use query_builder::*;
                use query_builder::nodes::Identifier;
                use query_source::{AppearsInFromClause, Once, Never};
                use query_source::joins::{Join, JoinOn};
                use types::*;
                pub use self::columns::*;
                /// Re-exports all of the columns of this table, as well as the
                /// table struct renamed to the module name. This is meant to be
                /// glob imported for functions which only deal with one table.
                pub mod dsl {
                    pub use super::columns::{id, roles, user_id, scope_id};
                    pub use super::table as scope_permissions;
                }
                #[allow(non_upper_case_globals, dead_code)]
                /// A tuple of all of the columns on this table
                pub const all_columns: (id, roles, user_id, scope_id) =
                    (id, roles, user_id, scope_id);
                #[allow(non_camel_case_types)]
                /// The actual table struct
                ///
                /// This is the type which provides the base methods of the query
                /// builder, such as `.select` and `.filter`.
                #[rustc_copy_clone_marker]
                pub struct table;
                #[automatically_derived]
                #[allow(unused_qualifications)]
                #[allow(non_camel_case_types)]
                impl ::std::fmt::Debug for table {
                    fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                        match *self {
                            table => {
                                let mut builder = __arg_0.debug_tuple("table");
                                builder.finish()
                            }
                        }
                    }
                }
                #[automatically_derived]
                #[allow(unused_qualifications)]
                #[allow(non_camel_case_types)]
                impl ::std::clone::Clone for table {
                    #[inline]
                    fn clone(&self) -> table {
                        {
                            *self
                        }
                    }
                }
                #[automatically_derived]
                #[allow(unused_qualifications)]
                #[allow(non_camel_case_types)]
                impl ::std::marker::Copy for table {}
                impl table {
                    #[allow(dead_code)]
                    /// Represents `table_name.*`, which is sometimes necessary
                    /// for efficient count queries. It cannot be used in place of
                    /// `all_columns`
                    pub fn star(&self) -> star {
                        star
                    }
                }
                /// The SQL type of all of the columns on this table
                pub type SqlType = (Uuid, Array<Scope_roles>, Uuid, Uuid);
                /// Helper type for representing a boxed query from this table
                pub type BoxedQuery<'a, DB, ST = SqlType> = BoxedSelectStatement<'a, ST, table, DB>;
                impl QuerySource for table {
                    type FromClause = Identifier<'static>;
                    type DefaultSelection = <Self as Table>::AllColumns;
                    fn from_clause(&self) -> Self::FromClause {
                        Identifier("scope_permissions")
                    }
                    fn default_selection(&self) -> Self::DefaultSelection {
                        Self::all_columns()
                    }
                }
                impl AsQuery for table {
                    type SqlType = SqlType;
                    type Query = SelectStatement<Self>;
                    fn as_query(self) -> Self::Query {
                        SelectStatement::simple(self)
                    }
                }
                impl Table for table {
                    type PrimaryKey = columns::id;
                    type AllColumns = (id, roles, user_id, scope_id);
                    fn primary_key(&self) -> Self::PrimaryKey {
                        columns::id
                    }
                    fn all_columns() -> Self::AllColumns {
                        (id, roles, user_id, scope_id)
                    }
                }
                impl HasTable for table {
                    type Table = Self;
                    fn table() -> Self::Table {
                        table
                    }
                }
                impl IntoUpdateTarget for table {
                    type
                    WhereClause
                    =
                    <<Self as AsQuery>::Query as
                    IntoUpdateTarget>::WhereClause;
                    fn into_update_target(self) -> UpdateTarget<Self::Table, Self::WhereClause> {
                        self.as_query().into_update_target()
                    }
                }
                impl AppearsInFromClause<table> for table {
                    type Count = Once;
                }
                impl<T> AppearsInFromClause<T> for table
                    where T: Table + JoinTo<table>
                {
                    type Count = Never;
                }
                impl<Left, Right, Kind> JoinTo<Join<Left, Right, Kind>> for table
                    where Join<Left, Right, Kind>: JoinTo<table>
                {
                    type FromClause = Join<Left, Right, Kind>;
                    type
                    OnClause
                    =
                    <Join<Left, Right, Kind> as JoinTo<table>>::OnClause;
                    fn join_target(rhs: Join<Left, Right, Kind>)
                                   -> (Self::FromClause, Self::OnClause) {
                        let (_, on_clause) = Join::join_target(table);
                        (rhs, on_clause)
                    }
                }
                impl<Join, On> JoinTo<JoinOn<Join, On>> for table
                    where JoinOn<Join, On>: JoinTo<table>
                {
                    type FromClause = JoinOn<Join, On>;
                    type OnClause = <JoinOn<Join, On> as JoinTo<table>>::OnClause;
                    fn join_target(rhs: JoinOn<Join, On>) -> (Self::FromClause, Self::OnClause) {
                        let (_, on_clause) = JoinOn::join_target(table);
                        (rhs, on_clause)
                    }
                }
                impl<F, S, D, W, O, L, Of, G> JoinTo<SelectStatement<F, S, D, W, O, L, Of, G>> for table
                    where SelectStatement<F, S, D, W, O, L, Of, G>: JoinTo<table>
                {
                    type FromClause = SelectStatement<F, S, D, W, O, L, Of, G>;
                    type
                    OnClause
                    =
                    <SelectStatement<F, S, D, W, O, L, Of, G> as
                    JoinTo<table>>::OnClause;
                    fn join_target(rhs: SelectStatement<F, S, D, W, O, L, Of, G>)
                                   -> (Self::FromClause, Self::OnClause) {
                        let (_, on_clause) = SelectStatement::join_target(table);
                        (rhs, on_clause)
                    }
                }
                impl<'a, QS, ST, DB> JoinTo<BoxedSelectStatement<'a, QS, ST, DB>> for table
                    where BoxedSelectStatement<'a, QS, ST, DB>: JoinTo<table>
                {
                    type FromClause = BoxedSelectStatement<'a, QS, ST, DB>;
                    type
                    OnClause
                    =
                    <BoxedSelectStatement<'a, QS, ST, DB> as
                    JoinTo<table>>::OnClause;
                    fn join_target(rhs: BoxedSelectStatement<'a, QS, ST, DB>)
                                   -> (Self::FromClause, Self::OnClause) {
                        let (_, on_clause) = BoxedSelectStatement::join_target(table);
                        (rhs, on_clause)
                    }
                }
                impl ::query_builder::QueryId for table {
                    type QueryId = Self;
                    fn has_static_query_id() -> bool {
                        true
                    }
                }
                /// Contains all of the columns of this table
                pub mod columns {
                    use super::table;
                    use {Expression, SelectableExpression, AppearsOnTable, QuerySource};
                    use backend::Backend;
                    use query_builder::{QueryFragment, AstPass, SelectStatement};
                    use query_source::joins::{Join, JoinOn, Inner, LeftOuter};
                    use query_source::{AppearsInFromClause, Once, Never};
                    use result::QueryResult;
                    use types::*;
                    #[allow(non_camel_case_types, dead_code)]
                    /// Represents `table_name.*`, which is sometimes needed for
                    /// efficient count queries. It cannot be used in place of
                    /// `all_columns`, and has a `SqlType` of `()` to prevent it
                    /// being used that way
                    #[rustc_copy_clone_marker]
                    pub struct star;
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    #[allow(non_camel_case_types, dead_code)]
                    impl ::std::fmt::Debug for star {
                        fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                            match *self {
                                star => {
                                    let mut builder = __arg_0.debug_tuple("star");
                                    builder.finish()
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    #[allow(non_camel_case_types, dead_code)]
                    impl ::std::clone::Clone for star {
                        #[inline]
                        fn clone(&self) -> star {
                            {
                                *self
                            }
                        }
                    }
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    #[allow(non_camel_case_types, dead_code)]
                    impl ::std::marker::Copy for star {}
                    impl Expression for star {
                        type SqlType = ();
                    }
                    impl<DB: Backend> QueryFragment<DB> for star
                        where <table as QuerySource>::FromClause: QueryFragment<DB>
                    {
                        fn walk_ast(&self, mut out: AstPass<DB>) -> QueryResult<()> {
                            table.from_clause().walk_ast(out.reborrow())?;
                            out.push_sql(".*");
                            Ok(())
                        }
                    }
                    impl SelectableExpression<table> for star {}
                    impl AppearsOnTable<table> for star {}
                    #[doc =
                          r" The `id` column of the `scope_permissions` table."]
                    #[doc = r""]
                    #[doc = r" Its SQL type is `Uuid`."]
                    #[doc = r""]
                    #[doc = r" (Automatically generated by Diesel.)"]
                    #[allow(non_camel_case_types, dead_code)]
                    #[rustc_copy_clone_marker]
                    pub struct id;
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    #[allow(non_camel_case_types, dead_code)]
                    impl ::std::fmt::Debug for id {
                        fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                            match *self {
                                id => {
                                    let mut builder = __arg_0.debug_tuple("id");
                                    builder.finish()
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    #[allow(non_camel_case_types, dead_code)]
                    impl ::std::clone::Clone for id {
                        #[inline]
                        fn clone(&self) -> id {
                            {
                                *self
                            }
                        }
                    }
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    #[allow(non_camel_case_types, dead_code)]
                    impl ::std::marker::Copy for id {}
                    impl ::expression::Expression for id {
                        type SqlType = Uuid;
                    }
                    impl<DB> ::query_builder::QueryFragment<DB> for id
                        where DB: ::backend::Backend,
                              <table as QuerySource>::FromClause: QueryFragment<DB>
                    {
                        fn walk_ast(&self,
                                    mut out: ::query_builder::AstPass<DB>)
                                    -> ::result::QueryResult<()> {
                            table.from_clause().walk_ast(out.reborrow())?;
                            out.push_sql(".");
                            out.push_identifier("id")
                        }
                    }
                    impl ::query_builder::QueryId for id {
                        type QueryId = Self;
                        fn has_static_query_id() -> bool {
                            true
                        }
                    }
                    impl SelectableExpression<table> for id {}
                    impl<QS> AppearsOnTable<QS> for id
                        where QS: AppearsInFromClause<table, Count = Once>
                    {
                    }
                    impl<Left, Right> SelectableExpression<Join<Left, Right, LeftOuter>> for id
                        where id: AppearsOnTable<Join<Left, Right, LeftOuter>>,
                              Left: AppearsInFromClause<table, Count = Once>,
                              Right: AppearsInFromClause<table, Count = Never>
                    {
                    }
                    impl<Left, Right> SelectableExpression<Join<Left, Right, Inner>> for id
                        where id: AppearsOnTable<Join<Left, Right, Inner>>,
                              Join<Left, Right, Inner>: AppearsInFromClause<table, Count = Once>
                    {
                    }
                    impl<Join, On> SelectableExpression<JoinOn<Join, On>> for id
                        where id: SelectableExpression<Join> + AppearsOnTable<JoinOn<Join, On>>
                    {
                    }
                    impl<From> SelectableExpression<SelectStatement<From>> for id
                        where id: SelectableExpression<From> + AppearsOnTable<SelectStatement<From>>
                    {
                    }
                    impl ::expression::NonAggregate for id {}
                    impl ::query_source::Column for id {
                        type Table = table;
                        fn name() -> &'static str {
                            "id"
                        }
                    }
                    impl <T> ::EqAll<T> for id where
                     T: ::expression::AsExpression<Uuid>,
                     ::expression::helper_types::Eq<id,
                                                    T>: ::Expression<SqlType =
                     ::types::Bool> {
                        type
                        Output
                        =
                        ::expression::helper_types::Eq<Self, T>;
                        fn eq_all(self, rhs: T) -> Self::Output {
                            ::expression::operators::Eq::new(self,
                                                             rhs.as_expression())
                        }
                    }
                    #[doc =
                          r" The `roles` column of the `scope_permissions` table."]
                    #[doc = r""]
                    #[doc = r" Its SQL type is `Array<Scope_roles>`."]
                    #[doc = r""]
                    #[doc = r" (Automatically generated by Diesel.)"]
                    #[allow(non_camel_case_types, dead_code)]
                    #[rustc_copy_clone_marker]
                    pub struct roles;
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    #[allow(non_camel_case_types, dead_code)]
                    impl ::std::fmt::Debug for roles {
                        fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                            match *self {
                                roles => {
                                    let mut builder = __arg_0.debug_tuple("roles");
                                    builder.finish()
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    #[allow(non_camel_case_types, dead_code)]
                    impl ::std::clone::Clone for roles {
                        #[inline]
                        fn clone(&self) -> roles {
                            {
                                *self
                            }
                        }
                    }
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    #[allow(non_camel_case_types, dead_code)]
                    impl ::std::marker::Copy for roles {}
                    impl ::expression::Expression for roles {
                        type SqlType = Array<Scope_roles>;
                    }
                    impl<DB> ::query_builder::QueryFragment<DB> for roles
                        where DB: ::backend::Backend,
                              <table as QuerySource>::FromClause: QueryFragment<DB>
                    {
                        fn walk_ast(&self,
                                    mut out: ::query_builder::AstPass<DB>)
                                    -> ::result::QueryResult<()> {
                            table.from_clause().walk_ast(out.reborrow())?;
                            out.push_sql(".");
                            out.push_identifier("roles")
                        }
                    }
                    impl ::query_builder::QueryId for roles {
                        type QueryId = Self;
                        fn has_static_query_id() -> bool {
                            true
                        }
                    }
                    impl SelectableExpression<table> for roles {}
                    impl<QS> AppearsOnTable<QS> for roles
                        where QS: AppearsInFromClause<table, Count = Once>
                    {
                    }
                    impl<Left, Right> SelectableExpression<Join<Left, Right, LeftOuter>> for roles
                        where roles: AppearsOnTable<Join<Left, Right, LeftOuter>>,
                              Left: AppearsInFromClause<table, Count = Once>,
                              Right: AppearsInFromClause<table, Count = Never>
                    {
                    }
                    impl<Left, Right> SelectableExpression<Join<Left, Right, Inner>> for roles
                        where roles: AppearsOnTable<Join<Left, Right, Inner>>,
                              Join<Left, Right, Inner>: AppearsInFromClause<table, Count = Once>
                    {
                    }
                    impl<Join, On> SelectableExpression<JoinOn<Join, On>> for roles
                        where roles: SelectableExpression<Join> + AppearsOnTable<JoinOn<Join, On>>
                    {
                    }
                    impl <From> SelectableExpression<SelectStatement<From>>
                     for roles where roles: SelectableExpression<From> +
                     AppearsOnTable<SelectStatement<From>> {
                    }
                    impl ::expression::NonAggregate for roles {}
                    impl ::query_source::Column for roles {
                        type Table = table;
                        fn name() -> &'static str {
                            "roles"
                        }
                    }
                    impl <T> ::EqAll<T> for roles where
                     T: ::expression::AsExpression<Array<Scope_roles>>,
                     ::expression::helper_types::Eq<roles,
                                                    T>: ::Expression<SqlType =
                     ::types::Bool> {
                        type
                        Output
                        =
                        ::expression::helper_types::Eq<Self, T>;
                        fn eq_all(self, rhs: T) -> Self::Output {
                            ::expression::operators::Eq::new(self,
                                                             rhs.as_expression())
                        }
                    }
                    #[doc =
                          r" The `user_id` column of the `scope_permissions` table."]
                    #[doc = r""]
                    #[doc = r" Its SQL type is `Uuid`."]
                    #[doc = r""]
                    #[doc = r" (Automatically generated by Diesel.)"]
                    #[allow(non_camel_case_types, dead_code)]
                    #[rustc_copy_clone_marker]
                    pub struct user_id;
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    #[allow(non_camel_case_types, dead_code)]
                    impl ::std::fmt::Debug for user_id {
                        fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                            match *self {
                                user_id => {
                                    let mut builder = __arg_0.debug_tuple("user_id");
                                    builder.finish()
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    #[allow(non_camel_case_types, dead_code)]
                    impl ::std::clone::Clone for user_id {
                        #[inline]
                        fn clone(&self) -> user_id {
                            {
                                *self
                            }
                        }
                    }
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    #[allow(non_camel_case_types, dead_code)]
                    impl ::std::marker::Copy for user_id {}
                    impl ::expression::Expression for user_id {
                        type SqlType = Uuid;
                    }
                    impl<DB> ::query_builder::QueryFragment<DB> for user_id
                        where DB: ::backend::Backend,
                              <table as QuerySource>::FromClause: QueryFragment<DB>
                    {
                        fn walk_ast(&self,
                                    mut out: ::query_builder::AstPass<DB>)
                                    -> ::result::QueryResult<()> {
                            table.from_clause().walk_ast(out.reborrow())?;
                            out.push_sql(".");
                            out.push_identifier("user_id")
                        }
                    }
                    impl ::query_builder::QueryId for user_id {
                        type QueryId = Self;
                        fn has_static_query_id() -> bool {
                            true
                        }
                    }
                    impl SelectableExpression<table> for user_id {}
                    impl<QS> AppearsOnTable<QS> for user_id
                        where QS: AppearsInFromClause<table, Count = Once>
                    {
                    }
                    impl<Left, Right> SelectableExpression<Join<Left, Right, LeftOuter>> for user_id
                        where user_id: AppearsOnTable<Join<Left, Right, LeftOuter>>,
                              Left: AppearsInFromClause<table, Count = Once>,
                              Right: AppearsInFromClause<table, Count = Never>
                    {
                    }
                    impl<Left, Right> SelectableExpression<Join<Left, Right, Inner>> for user_id
                        where user_id: AppearsOnTable<Join<Left, Right, Inner>>,
                              Join<Left, Right, Inner>: AppearsInFromClause<table, Count = Once>
                    {
                    }
                    impl<Join, On> SelectableExpression<JoinOn<Join, On>> for user_id
                        where user_id: SelectableExpression<Join> + AppearsOnTable<JoinOn<Join, On>>
                    {
                    }
                    impl <From> SelectableExpression<SelectStatement<From>>
                     for user_id where user_id: SelectableExpression<From> +
                     AppearsOnTable<SelectStatement<From>> {
                    }
                    impl ::expression::NonAggregate for user_id {}
                    impl ::query_source::Column for user_id {
                        type Table = table;
                        fn name() -> &'static str {
                            "user_id"
                        }
                    }
                    impl <T> ::EqAll<T> for user_id where
                     T: ::expression::AsExpression<Uuid>,
                     ::expression::helper_types::Eq<user_id,
                                                    T>: ::Expression<SqlType =
                     ::types::Bool> {
                        type
                        Output
                        =
                        ::expression::helper_types::Eq<Self, T>;
                        fn eq_all(self, rhs: T) -> Self::Output {
                            ::expression::operators::Eq::new(self,
                                                             rhs.as_expression())
                        }
                    }
                    #[doc =
                          r" The `scope_id` column of the `scope_permissions` table."]
                    #[doc = r""]
                    #[doc = r" Its SQL type is `Uuid`."]
                    #[doc = r""]
                    #[doc = r" (Automatically generated by Diesel.)"]
                    #[allow(non_camel_case_types, dead_code)]
                    #[rustc_copy_clone_marker]
                    pub struct scope_id;
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    #[allow(non_camel_case_types, dead_code)]
                    impl ::std::fmt::Debug for scope_id {
                        fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                            match *self {
                                scope_id => {
                                    let mut builder = __arg_0.debug_tuple("scope_id");
                                    builder.finish()
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    #[allow(non_camel_case_types, dead_code)]
                    impl ::std::clone::Clone for scope_id {
                        #[inline]
                        fn clone(&self) -> scope_id {
                            {
                                *self
                            }
                        }
                    }
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    #[allow(non_camel_case_types, dead_code)]
                    impl ::std::marker::Copy for scope_id {}
                    impl ::expression::Expression for scope_id {
                        type SqlType = Uuid;
                    }
                    impl<DB> ::query_builder::QueryFragment<DB> for scope_id
                        where DB: ::backend::Backend,
                              <table as QuerySource>::FromClause: QueryFragment<DB>
                    {
                        fn walk_ast(&self,
                                    mut out: ::query_builder::AstPass<DB>)
                                    -> ::result::QueryResult<()> {
                            table.from_clause().walk_ast(out.reborrow())?;
                            out.push_sql(".");
                            out.push_identifier("scope_id")
                        }
                    }
                    impl ::query_builder::QueryId for scope_id {
                        type QueryId = Self;
                        fn has_static_query_id() -> bool {
                            true
                        }
                    }
                    impl SelectableExpression<table> for scope_id {}
                    impl<QS> AppearsOnTable<QS> for scope_id
                        where QS: AppearsInFromClause<table, Count = Once>
                    {
                    }
                    impl<Left, Right> SelectableExpression<Join<Left, Right, LeftOuter>> for scope_id
                        where scope_id: AppearsOnTable<Join<Left, Right, LeftOuter>>,
                              Left: AppearsInFromClause<table, Count = Once>,
                              Right: AppearsInFromClause<table, Count = Never>
                    {
                    }
                    impl<Left, Right> SelectableExpression<Join<Left, Right, Inner>> for scope_id
                        where scope_id: AppearsOnTable<Join<Left, Right, Inner>>,
                              Join<Left, Right, Inner>: AppearsInFromClause<table, Count = Once>
                    {
                    }
                    impl <Join, On> SelectableExpression<JoinOn<Join, On>> for
                     scope_id where scope_id: SelectableExpression<Join> +
                     AppearsOnTable<JoinOn<Join, On>> {
                    }
                    impl <From> SelectableExpression<SelectStatement<From>>
                     for scope_id where scope_id: SelectableExpression<From> +
                     AppearsOnTable<SelectStatement<From>> {
                    }
                    impl ::expression::NonAggregate for scope_id {}
                    impl ::query_source::Column for scope_id {
                        type Table = table;
                        fn name() -> &'static str {
                            "scope_id"
                        }
                    }
                    impl <T> ::EqAll<T> for scope_id where
                     T: ::expression::AsExpression<Uuid>,
                     ::expression::helper_types::Eq<scope_id,
                                                    T>: ::Expression<SqlType =
                     ::types::Bool> {
                        type
                        Output
                        =
                        ::expression::helper_types::Eq<Self, T>;
                        fn eq_all(self, rhs: T) -> Self::Output {
                            ::expression::operators::Eq::new(self,
                                                             rhs.as_expression())
                        }
                    }
                }
            }
        }
        pub use self::infer_scope_permissions::*;
        mod infer_scope_transactions {
            #[infer_table_from_schema_options(database_url =
                                                  "postgres://ryan:@localhost:5432/rocket",
                                              table_name =
                                                  "scope_transactions")]
            struct __DieselInferTableFromSchema;
            #[doc = r" Representation of the `scope_transactions` table."]
            #[doc = r""]
            #[doc = r" (Automatically generated by Diesel.)"]
            pub mod scope_transactions {
                #![allow(dead_code)]
                use {QuerySource, Table, JoinTo};
                use associations::HasTable;
                use query_builder::*;
                use query_builder::nodes::Identifier;
                use query_source::{AppearsInFromClause, Once, Never};
                use query_source::joins::{Join, JoinOn};
                use types::*;
                pub use self::columns::*;
                /// Re-exports all of the columns of this table, as well as the
                /// table struct renamed to the module name. This is meant to be
                /// glob imported for functions which only deal with one table.
                pub mod dsl {
                    pub use super::columns::{id, user_id, scope_id, previous_transaction_id};
                    pub use super::table as scope_transactions;
                }
                #[allow(non_upper_case_globals, dead_code)]
                /// A tuple of all of the columns on this table
                pub const all_columns: (id, user_id, scope_id, previous_transaction_id) =
                    (id, user_id, scope_id, previous_transaction_id);
                #[allow(non_camel_case_types)]
                /// The actual table struct
                ///
                /// This is the type which provides the base methods of the query
                /// builder, such as `.select` and `.filter`.
                #[rustc_copy_clone_marker]
                pub struct table;
                #[automatically_derived]
                #[allow(unused_qualifications)]
                #[allow(non_camel_case_types)]
                impl ::std::fmt::Debug for table {
                    fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                        match *self {
                            table => {
                                let mut builder = __arg_0.debug_tuple("table");
                                builder.finish()
                            }
                        }
                    }
                }
                #[automatically_derived]
                #[allow(unused_qualifications)]
                #[allow(non_camel_case_types)]
                impl ::std::clone::Clone for table {
                    #[inline]
                    fn clone(&self) -> table {
                        {
                            *self
                        }
                    }
                }
                #[automatically_derived]
                #[allow(unused_qualifications)]
                #[allow(non_camel_case_types)]
                impl ::std::marker::Copy for table {}
                impl table {
                    #[allow(dead_code)]
                    /// Represents `table_name.*`, which is sometimes necessary
                    /// for efficient count queries. It cannot be used in place of
                    /// `all_columns`
                    pub fn star(&self) -> star {
                        star
                    }
                }
                /// The SQL type of all of the columns on this table
                pub type SqlType = (Uuid, Uuid, Uuid, Nullable<Uuid>);
                /// Helper type for representing a boxed query from this table
                pub type BoxedQuery<'a, DB, ST = SqlType> = BoxedSelectStatement<'a, ST, table, DB>;
                impl QuerySource for table {
                    type FromClause = Identifier<'static>;
                    type DefaultSelection = <Self as Table>::AllColumns;
                    fn from_clause(&self) -> Self::FromClause {
                        Identifier("scope_transactions")
                    }
                    fn default_selection(&self) -> Self::DefaultSelection {
                        Self::all_columns()
                    }
                }
                impl AsQuery for table {
                    type SqlType = SqlType;
                    type Query = SelectStatement<Self>;
                    fn as_query(self) -> Self::Query {
                        SelectStatement::simple(self)
                    }
                }
                impl Table for table {
                    type PrimaryKey = columns::id;
                    type AllColumns = (id, user_id, scope_id, previous_transaction_id);
                    fn primary_key(&self) -> Self::PrimaryKey {
                        columns::id
                    }
                    fn all_columns() -> Self::AllColumns {
                        (id, user_id, scope_id, previous_transaction_id)
                    }
                }
                impl HasTable for table {
                    type Table = Self;
                    fn table() -> Self::Table {
                        table
                    }
                }
                impl IntoUpdateTarget for table {
                    type
                    WhereClause
                    =
                    <<Self as AsQuery>::Query as
                    IntoUpdateTarget>::WhereClause;
                    fn into_update_target(self) -> UpdateTarget<Self::Table, Self::WhereClause> {
                        self.as_query().into_update_target()
                    }
                }
                impl AppearsInFromClause<table> for table {
                    type Count = Once;
                }
                impl<T> AppearsInFromClause<T> for table
                    where T: Table + JoinTo<table>
                {
                    type Count = Never;
                }
                impl<Left, Right, Kind> JoinTo<Join<Left, Right, Kind>> for table
                    where Join<Left, Right, Kind>: JoinTo<table>
                {
                    type FromClause = Join<Left, Right, Kind>;
                    type
                    OnClause
                    =
                    <Join<Left, Right, Kind> as JoinTo<table>>::OnClause;
                    fn join_target(rhs: Join<Left, Right, Kind>)
                                   -> (Self::FromClause, Self::OnClause) {
                        let (_, on_clause) = Join::join_target(table);
                        (rhs, on_clause)
                    }
                }
                impl<Join, On> JoinTo<JoinOn<Join, On>> for table
                    where JoinOn<Join, On>: JoinTo<table>
                {
                    type FromClause = JoinOn<Join, On>;
                    type OnClause = <JoinOn<Join, On> as JoinTo<table>>::OnClause;
                    fn join_target(rhs: JoinOn<Join, On>) -> (Self::FromClause, Self::OnClause) {
                        let (_, on_clause) = JoinOn::join_target(table);
                        (rhs, on_clause)
                    }
                }
                impl<F, S, D, W, O, L, Of, G> JoinTo<SelectStatement<F, S, D, W, O, L, Of, G>> for table
                    where SelectStatement<F, S, D, W, O, L, Of, G>: JoinTo<table>
                {
                    type FromClause = SelectStatement<F, S, D, W, O, L, Of, G>;
                    type
                    OnClause
                    =
                    <SelectStatement<F, S, D, W, O, L, Of, G> as
                    JoinTo<table>>::OnClause;
                    fn join_target(rhs: SelectStatement<F, S, D, W, O, L, Of, G>)
                                   -> (Self::FromClause, Self::OnClause) {
                        let (_, on_clause) = SelectStatement::join_target(table);
                        (rhs, on_clause)
                    }
                }
                impl<'a, QS, ST, DB> JoinTo<BoxedSelectStatement<'a, QS, ST, DB>> for table
                    where BoxedSelectStatement<'a, QS, ST, DB>: JoinTo<table>
                {
                    type FromClause = BoxedSelectStatement<'a, QS, ST, DB>;
                    type
                    OnClause
                    =
                    <BoxedSelectStatement<'a, QS, ST, DB> as
                    JoinTo<table>>::OnClause;
                    fn join_target(rhs: BoxedSelectStatement<'a, QS, ST, DB>)
                                   -> (Self::FromClause, Self::OnClause) {
                        let (_, on_clause) = BoxedSelectStatement::join_target(table);
                        (rhs, on_clause)
                    }
                }
                impl ::query_builder::QueryId for table {
                    type QueryId = Self;
                    fn has_static_query_id() -> bool {
                        true
                    }
                }
                /// Contains all of the columns of this table
                pub mod columns {
                    use super::table;
                    use {Expression, SelectableExpression, AppearsOnTable, QuerySource};
                    use backend::Backend;
                    use query_builder::{QueryFragment, AstPass, SelectStatement};
                    use query_source::joins::{Join, JoinOn, Inner, LeftOuter};
                    use query_source::{AppearsInFromClause, Once, Never};
                    use result::QueryResult;
                    use types::*;
                    #[allow(non_camel_case_types, dead_code)]
                    /// Represents `table_name.*`, which is sometimes needed for
                    /// efficient count queries. It cannot be used in place of
                    /// `all_columns`, and has a `SqlType` of `()` to prevent it
                    /// being used that way
                    #[rustc_copy_clone_marker]
                    pub struct star;
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    #[allow(non_camel_case_types, dead_code)]
                    impl ::std::fmt::Debug for star {
                        fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                            match *self {
                                star => {
                                    let mut builder = __arg_0.debug_tuple("star");
                                    builder.finish()
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    #[allow(non_camel_case_types, dead_code)]
                    impl ::std::clone::Clone for star {
                        #[inline]
                        fn clone(&self) -> star {
                            {
                                *self
                            }
                        }
                    }
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    #[allow(non_camel_case_types, dead_code)]
                    impl ::std::marker::Copy for star {}
                    impl Expression for star {
                        type SqlType = ();
                    }
                    impl<DB: Backend> QueryFragment<DB> for star
                        where <table as QuerySource>::FromClause: QueryFragment<DB>
                    {
                        fn walk_ast(&self, mut out: AstPass<DB>) -> QueryResult<()> {
                            table.from_clause().walk_ast(out.reborrow())?;
                            out.push_sql(".*");
                            Ok(())
                        }
                    }
                    impl SelectableExpression<table> for star {}
                    impl AppearsOnTable<table> for star {}
                    #[doc =
                          r" The `id` column of the `scope_transactions` table."]
                    #[doc = r""]
                    #[doc = r" Its SQL type is `Uuid`."]
                    #[doc = r""]
                    #[doc = r" (Automatically generated by Diesel.)"]
                    #[allow(non_camel_case_types, dead_code)]
                    #[rustc_copy_clone_marker]
                    pub struct id;
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    #[allow(non_camel_case_types, dead_code)]
                    impl ::std::fmt::Debug for id {
                        fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                            match *self {
                                id => {
                                    let mut builder = __arg_0.debug_tuple("id");
                                    builder.finish()
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    #[allow(non_camel_case_types, dead_code)]
                    impl ::std::clone::Clone for id {
                        #[inline]
                        fn clone(&self) -> id {
                            {
                                *self
                            }
                        }
                    }
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    #[allow(non_camel_case_types, dead_code)]
                    impl ::std::marker::Copy for id {}
                    impl ::expression::Expression for id {
                        type SqlType = Uuid;
                    }
                    impl<DB> ::query_builder::QueryFragment<DB> for id
                        where DB: ::backend::Backend,
                              <table as QuerySource>::FromClause: QueryFragment<DB>
                    {
                        fn walk_ast(&self,
                                    mut out: ::query_builder::AstPass<DB>)
                                    -> ::result::QueryResult<()> {
                            table.from_clause().walk_ast(out.reborrow())?;
                            out.push_sql(".");
                            out.push_identifier("id")
                        }
                    }
                    impl ::query_builder::QueryId for id {
                        type QueryId = Self;
                        fn has_static_query_id() -> bool {
                            true
                        }
                    }
                    impl SelectableExpression<table> for id {}
                    impl<QS> AppearsOnTable<QS> for id
                        where QS: AppearsInFromClause<table, Count = Once>
                    {
                    }
                    impl<Left, Right> SelectableExpression<Join<Left, Right, LeftOuter>> for id
                        where id: AppearsOnTable<Join<Left, Right, LeftOuter>>,
                              Left: AppearsInFromClause<table, Count = Once>,
                              Right: AppearsInFromClause<table, Count = Never>
                    {
                    }
                    impl<Left, Right> SelectableExpression<Join<Left, Right, Inner>> for id
                        where id: AppearsOnTable<Join<Left, Right, Inner>>,
                              Join<Left, Right, Inner>: AppearsInFromClause<table, Count = Once>
                    {
                    }
                    impl<Join, On> SelectableExpression<JoinOn<Join, On>> for id
                        where id: SelectableExpression<Join> + AppearsOnTable<JoinOn<Join, On>>
                    {
                    }
                    impl<From> SelectableExpression<SelectStatement<From>> for id
                        where id: SelectableExpression<From> + AppearsOnTable<SelectStatement<From>>
                    {
                    }
                    impl ::expression::NonAggregate for id {}
                    impl ::query_source::Column for id {
                        type Table = table;
                        fn name() -> &'static str {
                            "id"
                        }
                    }
                    impl <T> ::EqAll<T> for id where
                     T: ::expression::AsExpression<Uuid>,
                     ::expression::helper_types::Eq<id,
                                                    T>: ::Expression<SqlType =
                     ::types::Bool> {
                        type
                        Output
                        =
                        ::expression::helper_types::Eq<Self, T>;
                        fn eq_all(self, rhs: T) -> Self::Output {
                            ::expression::operators::Eq::new(self,
                                                             rhs.as_expression())
                        }
                    }
                    #[doc =
                          r" The `user_id` column of the `scope_transactions` table."]
                    #[doc = r""]
                    #[doc = r" Its SQL type is `Uuid`."]
                    #[doc = r""]
                    #[doc = r" (Automatically generated by Diesel.)"]
                    #[allow(non_camel_case_types, dead_code)]
                    #[rustc_copy_clone_marker]
                    pub struct user_id;
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    #[allow(non_camel_case_types, dead_code)]
                    impl ::std::fmt::Debug for user_id {
                        fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                            match *self {
                                user_id => {
                                    let mut builder = __arg_0.debug_tuple("user_id");
                                    builder.finish()
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    #[allow(non_camel_case_types, dead_code)]
                    impl ::std::clone::Clone for user_id {
                        #[inline]
                        fn clone(&self) -> user_id {
                            {
                                *self
                            }
                        }
                    }
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    #[allow(non_camel_case_types, dead_code)]
                    impl ::std::marker::Copy for user_id {}
                    impl ::expression::Expression for user_id {
                        type SqlType = Uuid;
                    }
                    impl<DB> ::query_builder::QueryFragment<DB> for user_id
                        where DB: ::backend::Backend,
                              <table as QuerySource>::FromClause: QueryFragment<DB>
                    {
                        fn walk_ast(&self,
                                    mut out: ::query_builder::AstPass<DB>)
                                    -> ::result::QueryResult<()> {
                            table.from_clause().walk_ast(out.reborrow())?;
                            out.push_sql(".");
                            out.push_identifier("user_id")
                        }
                    }
                    impl ::query_builder::QueryId for user_id {
                        type QueryId = Self;
                        fn has_static_query_id() -> bool {
                            true
                        }
                    }
                    impl SelectableExpression<table> for user_id {}
                    impl<QS> AppearsOnTable<QS> for user_id
                        where QS: AppearsInFromClause<table, Count = Once>
                    {
                    }
                    impl<Left, Right> SelectableExpression<Join<Left, Right, LeftOuter>> for user_id
                        where user_id: AppearsOnTable<Join<Left, Right, LeftOuter>>,
                              Left: AppearsInFromClause<table, Count = Once>,
                              Right: AppearsInFromClause<table, Count = Never>
                    {
                    }
                    impl<Left, Right> SelectableExpression<Join<Left, Right, Inner>> for user_id
                        where user_id: AppearsOnTable<Join<Left, Right, Inner>>,
                              Join<Left, Right, Inner>: AppearsInFromClause<table, Count = Once>
                    {
                    }
                    impl<Join, On> SelectableExpression<JoinOn<Join, On>> for user_id
                        where user_id: SelectableExpression<Join> + AppearsOnTable<JoinOn<Join, On>>
                    {
                    }
                    impl <From> SelectableExpression<SelectStatement<From>>
                     for user_id where user_id: SelectableExpression<From> +
                     AppearsOnTable<SelectStatement<From>> {
                    }
                    impl ::expression::NonAggregate for user_id {}
                    impl ::query_source::Column for user_id {
                        type Table = table;
                        fn name() -> &'static str {
                            "user_id"
                        }
                    }
                    impl <T> ::EqAll<T> for user_id where
                     T: ::expression::AsExpression<Uuid>,
                     ::expression::helper_types::Eq<user_id,
                                                    T>: ::Expression<SqlType =
                     ::types::Bool> {
                        type
                        Output
                        =
                        ::expression::helper_types::Eq<Self, T>;
                        fn eq_all(self, rhs: T) -> Self::Output {
                            ::expression::operators::Eq::new(self,
                                                             rhs.as_expression())
                        }
                    }
                    #[doc =
                          r" The `scope_id` column of the `scope_transactions` table."]
                    #[doc = r""]
                    #[doc = r" Its SQL type is `Uuid`."]
                    #[doc = r""]
                    #[doc = r" (Automatically generated by Diesel.)"]
                    #[allow(non_camel_case_types, dead_code)]
                    #[rustc_copy_clone_marker]
                    pub struct scope_id;
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    #[allow(non_camel_case_types, dead_code)]
                    impl ::std::fmt::Debug for scope_id {
                        fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                            match *self {
                                scope_id => {
                                    let mut builder = __arg_0.debug_tuple("scope_id");
                                    builder.finish()
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    #[allow(non_camel_case_types, dead_code)]
                    impl ::std::clone::Clone for scope_id {
                        #[inline]
                        fn clone(&self) -> scope_id {
                            {
                                *self
                            }
                        }
                    }
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    #[allow(non_camel_case_types, dead_code)]
                    impl ::std::marker::Copy for scope_id {}
                    impl ::expression::Expression for scope_id {
                        type SqlType = Uuid;
                    }
                    impl<DB> ::query_builder::QueryFragment<DB> for scope_id
                        where DB: ::backend::Backend,
                              <table as QuerySource>::FromClause: QueryFragment<DB>
                    {
                        fn walk_ast(&self,
                                    mut out: ::query_builder::AstPass<DB>)
                                    -> ::result::QueryResult<()> {
                            table.from_clause().walk_ast(out.reborrow())?;
                            out.push_sql(".");
                            out.push_identifier("scope_id")
                        }
                    }
                    impl ::query_builder::QueryId for scope_id {
                        type QueryId = Self;
                        fn has_static_query_id() -> bool {
                            true
                        }
                    }
                    impl SelectableExpression<table> for scope_id {}
                    impl<QS> AppearsOnTable<QS> for scope_id
                        where QS: AppearsInFromClause<table, Count = Once>
                    {
                    }
                    impl<Left, Right> SelectableExpression<Join<Left, Right, LeftOuter>> for scope_id
                        where scope_id: AppearsOnTable<Join<Left, Right, LeftOuter>>,
                              Left: AppearsInFromClause<table, Count = Once>,
                              Right: AppearsInFromClause<table, Count = Never>
                    {
                    }
                    impl<Left, Right> SelectableExpression<Join<Left, Right, Inner>> for scope_id
                        where scope_id: AppearsOnTable<Join<Left, Right, Inner>>,
                              Join<Left, Right, Inner>: AppearsInFromClause<table, Count = Once>
                    {
                    }
                    impl <Join, On> SelectableExpression<JoinOn<Join, On>> for
                     scope_id where scope_id: SelectableExpression<Join> +
                     AppearsOnTable<JoinOn<Join, On>> {
                    }
                    impl <From> SelectableExpression<SelectStatement<From>>
                     for scope_id where scope_id: SelectableExpression<From> +
                     AppearsOnTable<SelectStatement<From>> {
                    }
                    impl ::expression::NonAggregate for scope_id {}
                    impl ::query_source::Column for scope_id {
                        type Table = table;
                        fn name() -> &'static str {
                            "scope_id"
                        }
                    }
                    impl <T> ::EqAll<T> for scope_id where
                     T: ::expression::AsExpression<Uuid>,
                     ::expression::helper_types::Eq<scope_id,
                                                    T>: ::Expression<SqlType =
                     ::types::Bool> {
                        type
                        Output
                        =
                        ::expression::helper_types::Eq<Self, T>;
                        fn eq_all(self, rhs: T) -> Self::Output {
                            ::expression::operators::Eq::new(self,
                                                             rhs.as_expression())
                        }
                    }
                    #[doc =
                          r" The `previous_transaction_id` column of the `scope_transactions` table."]
                    #[doc = r""]
                    #[doc = r" Its SQL type is `Nullable<Uuid>`."]
                    #[doc = r""]
                    #[doc = r" (Automatically generated by Diesel.)"]
                    #[allow(non_camel_case_types, dead_code)]
                    #[rustc_copy_clone_marker]
                    pub struct previous_transaction_id;
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    #[allow(non_camel_case_types, dead_code)]
                    impl ::std::fmt::Debug for previous_transaction_id {
                        fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                            match *self {
                                previous_transaction_id => {
                                    let mut builder =
                                        __arg_0.debug_tuple("previous_transaction_id");
                                    builder.finish()
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    #[allow(non_camel_case_types, dead_code)]
                    impl ::std::clone::Clone for previous_transaction_id {
                        #[inline]
                        fn clone(&self) -> previous_transaction_id {
                            {
                                *self
                            }
                        }
                    }
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    #[allow(non_camel_case_types, dead_code)]
                    impl ::std::marker::Copy for previous_transaction_id {}
                    impl ::expression::Expression for previous_transaction_id {
                        type SqlType = Nullable<Uuid>;
                    }
                    impl<DB> ::query_builder::QueryFragment<DB> for previous_transaction_id
                        where DB: ::backend::Backend,
                              <table as QuerySource>::FromClause: QueryFragment<DB>
                    {
                        fn walk_ast(&self,
                                    mut out: ::query_builder::AstPass<DB>)
                                    -> ::result::QueryResult<()> {
                            table.from_clause().walk_ast(out.reborrow())?;
                            out.push_sql(".");
                            out.push_identifier("previous_transaction_id")
                        }
                    }
                    impl ::query_builder::QueryId for previous_transaction_id {
                        type QueryId = Self;
                        fn has_static_query_id() -> bool {
                            true
                        }
                    }
                    impl SelectableExpression<table> for previous_transaction_id {}
                    impl<QS> AppearsOnTable<QS> for previous_transaction_id
                        where QS: AppearsInFromClause<table, Count = Once>
                    {
                    }
                    impl<Left, Right> SelectableExpression<Join<Left, Right, LeftOuter>> for previous_transaction_id
                        where previous_transaction_id: AppearsOnTable<Join<Left, Right, LeftOuter>>,
                              Left: AppearsInFromClause<table, Count = Once>,
                              Right: AppearsInFromClause<table, Count = Never>
                    {
                    }
                    impl<Left, Right> SelectableExpression<Join<Left, Right, Inner>> for previous_transaction_id
                        where previous_transaction_id: AppearsOnTable<Join<Left, Right, Inner>>,
                              Join<Left, Right, Inner>: AppearsInFromClause<table, Count = Once>
                    {
                    }
                    impl <Join, On> SelectableExpression<JoinOn<Join, On>> for
                     previous_transaction_id where
                     previous_transaction_id: SelectableExpression<Join> +
                     AppearsOnTable<JoinOn<Join, On>> {
                    }
                    impl <From> SelectableExpression<SelectStatement<From>>
                     for previous_transaction_id where
                     previous_transaction_id: SelectableExpression<From> +
                     AppearsOnTable<SelectStatement<From>> {
                    }
                    impl ::expression::NonAggregate for previous_transaction_id {}
                    impl ::query_source::Column for previous_transaction_id {
                        type Table = table;
                        fn name() -> &'static str {
                            "previous_transaction_id"
                        }
                    }
                    impl <T> ::EqAll<T> for previous_transaction_id where
                     T: ::expression::AsExpression<Nullable<Uuid>>,
                     ::expression::helper_types::Eq<previous_transaction_id,
                                                    T>: ::Expression<SqlType =
                     ::types::Bool> {
                        type
                        Output
                        =
                        ::expression::helper_types::Eq<Self, T>;
                        fn eq_all(self, rhs: T) -> Self::Output {
                            ::expression::operators::Eq::new(self,
                                                             rhs.as_expression())
                        }
                    }
                }
            }
        }
        pub use self::infer_scope_transactions::*;
        mod infer_scopes {
            #[infer_table_from_schema_options(database_url =
                                                  "postgres://ryan:@localhost:5432/rocket",
                                              table_name = "scopes")]
            struct __DieselInferTableFromSchema;
            #[doc = r" Representation of the `scopes` table."]
            #[doc = r""]
            #[doc = r" (Automatically generated by Diesel.)"]
            pub mod scopes {
                #![allow(dead_code)]
                use {QuerySource, Table, JoinTo};
                use associations::HasTable;
                use query_builder::*;
                use query_builder::nodes::Identifier;
                use query_source::{AppearsInFromClause, Once, Never};
                use query_source::joins::{Join, JoinOn};
                use types::*;
                pub use self::columns::*;
                /// Re-exports all of the columns of this table, as well as the
                /// table struct renamed to the module name. This is meant to be
                /// glob imported for functions which only deal with one table.
                pub mod dsl {
                    pub use super::columns::{id, current_transaction_id};
                    pub use super::table as scopes;
                }
                #[allow(non_upper_case_globals, dead_code)]
                /// A tuple of all of the columns on this table
                pub const all_columns: (id, current_transaction_id) = (id, current_transaction_id);
                #[allow(non_camel_case_types)]
                /// The actual table struct
                ///
                /// This is the type which provides the base methods of the query
                /// builder, such as `.select` and `.filter`.
                #[rustc_copy_clone_marker]
                pub struct table;
                #[automatically_derived]
                #[allow(unused_qualifications)]
                #[allow(non_camel_case_types)]
                impl ::std::fmt::Debug for table {
                    fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                        match *self {
                            table => {
                                let mut builder = __arg_0.debug_tuple("table");
                                builder.finish()
                            }
                        }
                    }
                }
                #[automatically_derived]
                #[allow(unused_qualifications)]
                #[allow(non_camel_case_types)]
                impl ::std::clone::Clone for table {
                    #[inline]
                    fn clone(&self) -> table {
                        {
                            *self
                        }
                    }
                }
                #[automatically_derived]
                #[allow(unused_qualifications)]
                #[allow(non_camel_case_types)]
                impl ::std::marker::Copy for table {}
                impl table {
                    #[allow(dead_code)]
                    /// Represents `table_name.*`, which is sometimes necessary
                    /// for efficient count queries. It cannot be used in place of
                    /// `all_columns`
                    pub fn star(&self) -> star {
                        star
                    }
                }
                /// The SQL type of all of the columns on this table
                pub type SqlType = (Uuid, Nullable<Uuid>);
                /// Helper type for representing a boxed query from this table
                pub type BoxedQuery<'a, DB, ST = SqlType> = BoxedSelectStatement<'a, ST, table, DB>;
                impl QuerySource for table {
                    type FromClause = Identifier<'static>;
                    type DefaultSelection = <Self as Table>::AllColumns;
                    fn from_clause(&self) -> Self::FromClause {
                        Identifier("scopes")
                    }
                    fn default_selection(&self) -> Self::DefaultSelection {
                        Self::all_columns()
                    }
                }
                impl AsQuery for table {
                    type SqlType = SqlType;
                    type Query = SelectStatement<Self>;
                    fn as_query(self) -> Self::Query {
                        SelectStatement::simple(self)
                    }
                }
                impl Table for table {
                    type PrimaryKey = columns::id;
                    type AllColumns = (id, current_transaction_id);
                    fn primary_key(&self) -> Self::PrimaryKey {
                        columns::id
                    }
                    fn all_columns() -> Self::AllColumns {
                        (id, current_transaction_id)
                    }
                }
                impl HasTable for table {
                    type Table = Self;
                    fn table() -> Self::Table {
                        table
                    }
                }
                impl IntoUpdateTarget for table {
                    type
                    WhereClause
                    =
                    <<Self as AsQuery>::Query as
                    IntoUpdateTarget>::WhereClause;
                    fn into_update_target(self) -> UpdateTarget<Self::Table, Self::WhereClause> {
                        self.as_query().into_update_target()
                    }
                }
                impl AppearsInFromClause<table> for table {
                    type Count = Once;
                }
                impl<T> AppearsInFromClause<T> for table
                    where T: Table + JoinTo<table>
                {
                    type Count = Never;
                }
                impl<Left, Right, Kind> JoinTo<Join<Left, Right, Kind>> for table
                    where Join<Left, Right, Kind>: JoinTo<table>
                {
                    type FromClause = Join<Left, Right, Kind>;
                    type
                    OnClause
                    =
                    <Join<Left, Right, Kind> as JoinTo<table>>::OnClause;
                    fn join_target(rhs: Join<Left, Right, Kind>)
                                   -> (Self::FromClause, Self::OnClause) {
                        let (_, on_clause) = Join::join_target(table);
                        (rhs, on_clause)
                    }
                }
                impl<Join, On> JoinTo<JoinOn<Join, On>> for table
                    where JoinOn<Join, On>: JoinTo<table>
                {
                    type FromClause = JoinOn<Join, On>;
                    type OnClause = <JoinOn<Join, On> as JoinTo<table>>::OnClause;
                    fn join_target(rhs: JoinOn<Join, On>) -> (Self::FromClause, Self::OnClause) {
                        let (_, on_clause) = JoinOn::join_target(table);
                        (rhs, on_clause)
                    }
                }
                impl<F, S, D, W, O, L, Of, G> JoinTo<SelectStatement<F, S, D, W, O, L, Of, G>> for table
                    where SelectStatement<F, S, D, W, O, L, Of, G>: JoinTo<table>
                {
                    type FromClause = SelectStatement<F, S, D, W, O, L, Of, G>;
                    type
                    OnClause
                    =
                    <SelectStatement<F, S, D, W, O, L, Of, G> as
                    JoinTo<table>>::OnClause;
                    fn join_target(rhs: SelectStatement<F, S, D, W, O, L, Of, G>)
                                   -> (Self::FromClause, Self::OnClause) {
                        let (_, on_clause) = SelectStatement::join_target(table);
                        (rhs, on_clause)
                    }
                }
                impl<'a, QS, ST, DB> JoinTo<BoxedSelectStatement<'a, QS, ST, DB>> for table
                    where BoxedSelectStatement<'a, QS, ST, DB>: JoinTo<table>
                {
                    type FromClause = BoxedSelectStatement<'a, QS, ST, DB>;
                    type
                    OnClause
                    =
                    <BoxedSelectStatement<'a, QS, ST, DB> as
                    JoinTo<table>>::OnClause;
                    fn join_target(rhs: BoxedSelectStatement<'a, QS, ST, DB>)
                                   -> (Self::FromClause, Self::OnClause) {
                        let (_, on_clause) = BoxedSelectStatement::join_target(table);
                        (rhs, on_clause)
                    }
                }
                impl ::query_builder::QueryId for table {
                    type QueryId = Self;
                    fn has_static_query_id() -> bool {
                        true
                    }
                }
                /// Contains all of the columns of this table
                pub mod columns {
                    use super::table;
                    use {Expression, SelectableExpression, AppearsOnTable, QuerySource};
                    use backend::Backend;
                    use query_builder::{QueryFragment, AstPass, SelectStatement};
                    use query_source::joins::{Join, JoinOn, Inner, LeftOuter};
                    use query_source::{AppearsInFromClause, Once, Never};
                    use result::QueryResult;
                    use types::*;
                    #[allow(non_camel_case_types, dead_code)]
                    /// Represents `table_name.*`, which is sometimes needed for
                    /// efficient count queries. It cannot be used in place of
                    /// `all_columns`, and has a `SqlType` of `()` to prevent it
                    /// being used that way
                    #[rustc_copy_clone_marker]
                    pub struct star;
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    #[allow(non_camel_case_types, dead_code)]
                    impl ::std::fmt::Debug for star {
                        fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                            match *self {
                                star => {
                                    let mut builder = __arg_0.debug_tuple("star");
                                    builder.finish()
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    #[allow(non_camel_case_types, dead_code)]
                    impl ::std::clone::Clone for star {
                        #[inline]
                        fn clone(&self) -> star {
                            {
                                *self
                            }
                        }
                    }
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    #[allow(non_camel_case_types, dead_code)]
                    impl ::std::marker::Copy for star {}
                    impl Expression for star {
                        type SqlType = ();
                    }
                    impl<DB: Backend> QueryFragment<DB> for star
                        where <table as QuerySource>::FromClause: QueryFragment<DB>
                    {
                        fn walk_ast(&self, mut out: AstPass<DB>) -> QueryResult<()> {
                            table.from_clause().walk_ast(out.reborrow())?;
                            out.push_sql(".*");
                            Ok(())
                        }
                    }
                    impl SelectableExpression<table> for star {}
                    impl AppearsOnTable<table> for star {}
                    #[doc = r" The `id` column of the `scopes` table."]
                    #[doc = r""]
                    #[doc = r" Its SQL type is `Uuid`."]
                    #[doc = r""]
                    #[doc = r" (Automatically generated by Diesel.)"]
                    #[allow(non_camel_case_types, dead_code)]
                    #[rustc_copy_clone_marker]
                    pub struct id;
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    #[allow(non_camel_case_types, dead_code)]
                    impl ::std::fmt::Debug for id {
                        fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                            match *self {
                                id => {
                                    let mut builder = __arg_0.debug_tuple("id");
                                    builder.finish()
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    #[allow(non_camel_case_types, dead_code)]
                    impl ::std::clone::Clone for id {
                        #[inline]
                        fn clone(&self) -> id {
                            {
                                *self
                            }
                        }
                    }
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    #[allow(non_camel_case_types, dead_code)]
                    impl ::std::marker::Copy for id {}
                    impl ::expression::Expression for id {
                        type SqlType = Uuid;
                    }
                    impl<DB> ::query_builder::QueryFragment<DB> for id
                        where DB: ::backend::Backend,
                              <table as QuerySource>::FromClause: QueryFragment<DB>
                    {
                        fn walk_ast(&self,
                                    mut out: ::query_builder::AstPass<DB>)
                                    -> ::result::QueryResult<()> {
                            table.from_clause().walk_ast(out.reborrow())?;
                            out.push_sql(".");
                            out.push_identifier("id")
                        }
                    }
                    impl ::query_builder::QueryId for id {
                        type QueryId = Self;
                        fn has_static_query_id() -> bool {
                            true
                        }
                    }
                    impl SelectableExpression<table> for id {}
                    impl<QS> AppearsOnTable<QS> for id
                        where QS: AppearsInFromClause<table, Count = Once>
                    {
                    }
                    impl<Left, Right> SelectableExpression<Join<Left, Right, LeftOuter>> for id
                        where id: AppearsOnTable<Join<Left, Right, LeftOuter>>,
                              Left: AppearsInFromClause<table, Count = Once>,
                              Right: AppearsInFromClause<table, Count = Never>
                    {
                    }
                    impl<Left, Right> SelectableExpression<Join<Left, Right, Inner>> for id
                        where id: AppearsOnTable<Join<Left, Right, Inner>>,
                              Join<Left, Right, Inner>: AppearsInFromClause<table, Count = Once>
                    {
                    }
                    impl<Join, On> SelectableExpression<JoinOn<Join, On>> for id
                        where id: SelectableExpression<Join> + AppearsOnTable<JoinOn<Join, On>>
                    {
                    }
                    impl<From> SelectableExpression<SelectStatement<From>> for id
                        where id: SelectableExpression<From> + AppearsOnTable<SelectStatement<From>>
                    {
                    }
                    impl ::expression::NonAggregate for id {}
                    impl ::query_source::Column for id {
                        type Table = table;
                        fn name() -> &'static str {
                            "id"
                        }
                    }
                    impl <T> ::EqAll<T> for id where
                     T: ::expression::AsExpression<Uuid>,
                     ::expression::helper_types::Eq<id,
                                                    T>: ::Expression<SqlType =
                     ::types::Bool> {
                        type
                        Output
                        =
                        ::expression::helper_types::Eq<Self, T>;
                        fn eq_all(self, rhs: T) -> Self::Output {
                            ::expression::operators::Eq::new(self,
                                                             rhs.as_expression())
                        }
                    }
                    #[doc =
                          r" The `current_transaction_id` column of the `scopes` table."]
                    #[doc = r""]
                    #[doc = r" Its SQL type is `Nullable<Uuid>`."]
                    #[doc = r""]
                    #[doc = r" (Automatically generated by Diesel.)"]
                    #[allow(non_camel_case_types, dead_code)]
                    #[rustc_copy_clone_marker]
                    pub struct current_transaction_id;
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    #[allow(non_camel_case_types, dead_code)]
                    impl ::std::fmt::Debug for current_transaction_id {
                        fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                            match *self {
                                current_transaction_id => {
                                    let mut builder = __arg_0.debug_tuple("current_transaction_id");
                                    builder.finish()
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    #[allow(non_camel_case_types, dead_code)]
                    impl ::std::clone::Clone for current_transaction_id {
                        #[inline]
                        fn clone(&self) -> current_transaction_id {
                            {
                                *self
                            }
                        }
                    }
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    #[allow(non_camel_case_types, dead_code)]
                    impl ::std::marker::Copy for current_transaction_id {}
                    impl ::expression::Expression for current_transaction_id {
                        type SqlType = Nullable<Uuid>;
                    }
                    impl<DB> ::query_builder::QueryFragment<DB> for current_transaction_id
                        where DB: ::backend::Backend,
                              <table as QuerySource>::FromClause: QueryFragment<DB>
                    {
                        fn walk_ast(&self,
                                    mut out: ::query_builder::AstPass<DB>)
                                    -> ::result::QueryResult<()> {
                            table.from_clause().walk_ast(out.reborrow())?;
                            out.push_sql(".");
                            out.push_identifier("current_transaction_id")
                        }
                    }
                    impl ::query_builder::QueryId for current_transaction_id {
                        type QueryId = Self;
                        fn has_static_query_id() -> bool {
                            true
                        }
                    }
                    impl SelectableExpression<table> for current_transaction_id {}
                    impl<QS> AppearsOnTable<QS> for current_transaction_id
                        where QS: AppearsInFromClause<table, Count = Once>
                    {
                    }
                    impl<Left, Right> SelectableExpression<Join<Left, Right, LeftOuter>> for current_transaction_id
                        where current_transaction_id: AppearsOnTable<Join<Left, Right, LeftOuter>>,
                              Left: AppearsInFromClause<table, Count = Once>,
                              Right: AppearsInFromClause<table, Count = Never>
                    {
                    }
                    impl<Left, Right> SelectableExpression<Join<Left, Right, Inner>> for current_transaction_id
                        where current_transaction_id: AppearsOnTable<Join<Left, Right, Inner>>,
                              Join<Left, Right, Inner>: AppearsInFromClause<table, Count = Once>
                    {
                    }
                    impl <Join, On> SelectableExpression<JoinOn<Join, On>> for
                     current_transaction_id where
                     current_transaction_id: SelectableExpression<Join> +
                     AppearsOnTable<JoinOn<Join, On>> {
                    }
                    impl <From> SelectableExpression<SelectStatement<From>>
                     for current_transaction_id where
                     current_transaction_id: SelectableExpression<From> +
                     AppearsOnTable<SelectStatement<From>> {
                    }
                    impl ::expression::NonAggregate for current_transaction_id {}
                    impl ::query_source::Column for current_transaction_id {
                        type Table = table;
                        fn name() -> &'static str {
                            "current_transaction_id"
                        }
                    }
                    impl <T> ::EqAll<T> for current_transaction_id where
                     T: ::expression::AsExpression<Nullable<Uuid>>,
                     ::expression::helper_types::Eq<current_transaction_id,
                                                    T>: ::Expression<SqlType =
                     ::types::Bool> {
                        type
                        Output
                        =
                        ::expression::helper_types::Eq<Self, T>;
                        fn eq_all(self, rhs: T) -> Self::Output {
                            ::expression::operators::Eq::new(self,
                                                             rhs.as_expression())
                        }
                    }
                }
            }
        }
        pub use self::infer_scopes::*;
        mod infer_users {
            #[infer_table_from_schema_options(database_url =
                                                  "postgres://ryan:@localhost:5432/rocket",
                                              table_name = "users")]
            struct __DieselInferTableFromSchema;
            #[doc = r" Representation of the `users` table."]
            #[doc = r""]
            #[doc = r" (Automatically generated by Diesel.)"]
            pub mod users {
                #![allow(dead_code)]
                use {QuerySource, Table, JoinTo};
                use associations::HasTable;
                use query_builder::*;
                use query_builder::nodes::Identifier;
                use query_source::{AppearsInFromClause, Once, Never};
                use query_source::joins::{Join, JoinOn};
                use types::*;
                pub use self::columns::*;
                /// Re-exports all of the columns of this table, as well as the
                /// table struct renamed to the module name. This is meant to be
                /// glob imported for functions which only deal with one table.
                pub mod dsl {
                    pub use super::columns::{id, email, password};
                    pub use super::table as users;
                }
                #[allow(non_upper_case_globals, dead_code)]
                /// A tuple of all of the columns on this table
                pub const all_columns: (id, email, password) = (id, email, password);
                #[allow(non_camel_case_types)]
                /// The actual table struct
                ///
                /// This is the type which provides the base methods of the query
                /// builder, such as `.select` and `.filter`.
                #[rustc_copy_clone_marker]
                pub struct table;
                #[automatically_derived]
                #[allow(unused_qualifications)]
                #[allow(non_camel_case_types)]
                impl ::std::fmt::Debug for table {
                    fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                        match *self {
                            table => {
                                let mut builder = __arg_0.debug_tuple("table");
                                builder.finish()
                            }
                        }
                    }
                }
                #[automatically_derived]
                #[allow(unused_qualifications)]
                #[allow(non_camel_case_types)]
                impl ::std::clone::Clone for table {
                    #[inline]
                    fn clone(&self) -> table {
                        {
                            *self
                        }
                    }
                }
                #[automatically_derived]
                #[allow(unused_qualifications)]
                #[allow(non_camel_case_types)]
                impl ::std::marker::Copy for table {}
                impl table {
                    #[allow(dead_code)]
                    /// Represents `table_name.*`, which is sometimes necessary
                    /// for efficient count queries. It cannot be used in place of
                    /// `all_columns`
                    pub fn star(&self) -> star {
                        star
                    }
                }
                /// The SQL type of all of the columns on this table
                pub type SqlType = (Uuid, Varchar, Varchar);
                /// Helper type for representing a boxed query from this table
                pub type BoxedQuery<'a, DB, ST = SqlType> = BoxedSelectStatement<'a, ST, table, DB>;
                impl QuerySource for table {
                    type FromClause = Identifier<'static>;
                    type DefaultSelection = <Self as Table>::AllColumns;
                    fn from_clause(&self) -> Self::FromClause {
                        Identifier("users")
                    }
                    fn default_selection(&self) -> Self::DefaultSelection {
                        Self::all_columns()
                    }
                }
                impl AsQuery for table {
                    type SqlType = SqlType;
                    type Query = SelectStatement<Self>;
                    fn as_query(self) -> Self::Query {
                        SelectStatement::simple(self)
                    }
                }
                impl Table for table {
                    type PrimaryKey = columns::id;
                    type AllColumns = (id, email, password);
                    fn primary_key(&self) -> Self::PrimaryKey {
                        columns::id
                    }
                    fn all_columns() -> Self::AllColumns {
                        (id, email, password)
                    }
                }
                impl HasTable for table {
                    type Table = Self;
                    fn table() -> Self::Table {
                        table
                    }
                }
                impl IntoUpdateTarget for table {
                    type
                    WhereClause
                    =
                    <<Self as AsQuery>::Query as
                    IntoUpdateTarget>::WhereClause;
                    fn into_update_target(self) -> UpdateTarget<Self::Table, Self::WhereClause> {
                        self.as_query().into_update_target()
                    }
                }
                impl AppearsInFromClause<table> for table {
                    type Count = Once;
                }
                impl<T> AppearsInFromClause<T> for table
                    where T: Table + JoinTo<table>
                {
                    type Count = Never;
                }
                impl<Left, Right, Kind> JoinTo<Join<Left, Right, Kind>> for table
                    where Join<Left, Right, Kind>: JoinTo<table>
                {
                    type FromClause = Join<Left, Right, Kind>;
                    type
                    OnClause
                    =
                    <Join<Left, Right, Kind> as JoinTo<table>>::OnClause;
                    fn join_target(rhs: Join<Left, Right, Kind>)
                                   -> (Self::FromClause, Self::OnClause) {
                        let (_, on_clause) = Join::join_target(table);
                        (rhs, on_clause)
                    }
                }
                impl<Join, On> JoinTo<JoinOn<Join, On>> for table
                    where JoinOn<Join, On>: JoinTo<table>
                {
                    type FromClause = JoinOn<Join, On>;
                    type OnClause = <JoinOn<Join, On> as JoinTo<table>>::OnClause;
                    fn join_target(rhs: JoinOn<Join, On>) -> (Self::FromClause, Self::OnClause) {
                        let (_, on_clause) = JoinOn::join_target(table);
                        (rhs, on_clause)
                    }
                }
                impl<F, S, D, W, O, L, Of, G> JoinTo<SelectStatement<F, S, D, W, O, L, Of, G>> for table
                    where SelectStatement<F, S, D, W, O, L, Of, G>: JoinTo<table>
                {
                    type FromClause = SelectStatement<F, S, D, W, O, L, Of, G>;
                    type
                    OnClause
                    =
                    <SelectStatement<F, S, D, W, O, L, Of, G> as
                    JoinTo<table>>::OnClause;
                    fn join_target(rhs: SelectStatement<F, S, D, W, O, L, Of, G>)
                                   -> (Self::FromClause, Self::OnClause) {
                        let (_, on_clause) = SelectStatement::join_target(table);
                        (rhs, on_clause)
                    }
                }
                impl<'a, QS, ST, DB> JoinTo<BoxedSelectStatement<'a, QS, ST, DB>> for table
                    where BoxedSelectStatement<'a, QS, ST, DB>: JoinTo<table>
                {
                    type FromClause = BoxedSelectStatement<'a, QS, ST, DB>;
                    type
                    OnClause
                    =
                    <BoxedSelectStatement<'a, QS, ST, DB> as
                    JoinTo<table>>::OnClause;
                    fn join_target(rhs: BoxedSelectStatement<'a, QS, ST, DB>)
                                   -> (Self::FromClause, Self::OnClause) {
                        let (_, on_clause) = BoxedSelectStatement::join_target(table);
                        (rhs, on_clause)
                    }
                }
                impl ::query_builder::QueryId for table {
                    type QueryId = Self;
                    fn has_static_query_id() -> bool {
                        true
                    }
                }
                /// Contains all of the columns of this table
                pub mod columns {
                    use super::table;
                    use {Expression, SelectableExpression, AppearsOnTable, QuerySource};
                    use backend::Backend;
                    use query_builder::{QueryFragment, AstPass, SelectStatement};
                    use query_source::joins::{Join, JoinOn, Inner, LeftOuter};
                    use query_source::{AppearsInFromClause, Once, Never};
                    use result::QueryResult;
                    use types::*;
                    #[allow(non_camel_case_types, dead_code)]
                    /// Represents `table_name.*`, which is sometimes needed for
                    /// efficient count queries. It cannot be used in place of
                    /// `all_columns`, and has a `SqlType` of `()` to prevent it
                    /// being used that way
                    #[rustc_copy_clone_marker]
                    pub struct star;
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    #[allow(non_camel_case_types, dead_code)]
                    impl ::std::fmt::Debug for star {
                        fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                            match *self {
                                star => {
                                    let mut builder = __arg_0.debug_tuple("star");
                                    builder.finish()
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    #[allow(non_camel_case_types, dead_code)]
                    impl ::std::clone::Clone for star {
                        #[inline]
                        fn clone(&self) -> star {
                            {
                                *self
                            }
                        }
                    }
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    #[allow(non_camel_case_types, dead_code)]
                    impl ::std::marker::Copy for star {}
                    impl Expression for star {
                        type SqlType = ();
                    }
                    impl<DB: Backend> QueryFragment<DB> for star
                        where <table as QuerySource>::FromClause: QueryFragment<DB>
                    {
                        fn walk_ast(&self, mut out: AstPass<DB>) -> QueryResult<()> {
                            table.from_clause().walk_ast(out.reborrow())?;
                            out.push_sql(".*");
                            Ok(())
                        }
                    }
                    impl SelectableExpression<table> for star {}
                    impl AppearsOnTable<table> for star {}
                    #[doc = r" The `id` column of the `users` table."]
                    #[doc = r""]
                    #[doc = r" Its SQL type is `Uuid`."]
                    #[doc = r""]
                    #[doc = r" (Automatically generated by Diesel.)"]
                    #[allow(non_camel_case_types, dead_code)]
                    #[rustc_copy_clone_marker]
                    pub struct id;
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    #[allow(non_camel_case_types, dead_code)]
                    impl ::std::fmt::Debug for id {
                        fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                            match *self {
                                id => {
                                    let mut builder = __arg_0.debug_tuple("id");
                                    builder.finish()
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    #[allow(non_camel_case_types, dead_code)]
                    impl ::std::clone::Clone for id {
                        #[inline]
                        fn clone(&self) -> id {
                            {
                                *self
                            }
                        }
                    }
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    #[allow(non_camel_case_types, dead_code)]
                    impl ::std::marker::Copy for id {}
                    impl ::expression::Expression for id {
                        type SqlType = Uuid;
                    }
                    impl<DB> ::query_builder::QueryFragment<DB> for id
                        where DB: ::backend::Backend,
                              <table as QuerySource>::FromClause: QueryFragment<DB>
                    {
                        fn walk_ast(&self,
                                    mut out: ::query_builder::AstPass<DB>)
                                    -> ::result::QueryResult<()> {
                            table.from_clause().walk_ast(out.reborrow())?;
                            out.push_sql(".");
                            out.push_identifier("id")
                        }
                    }
                    impl ::query_builder::QueryId for id {
                        type QueryId = Self;
                        fn has_static_query_id() -> bool {
                            true
                        }
                    }
                    impl SelectableExpression<table> for id {}
                    impl<QS> AppearsOnTable<QS> for id
                        where QS: AppearsInFromClause<table, Count = Once>
                    {
                    }
                    impl<Left, Right> SelectableExpression<Join<Left, Right, LeftOuter>> for id
                        where id: AppearsOnTable<Join<Left, Right, LeftOuter>>,
                              Left: AppearsInFromClause<table, Count = Once>,
                              Right: AppearsInFromClause<table, Count = Never>
                    {
                    }
                    impl<Left, Right> SelectableExpression<Join<Left, Right, Inner>> for id
                        where id: AppearsOnTable<Join<Left, Right, Inner>>,
                              Join<Left, Right, Inner>: AppearsInFromClause<table, Count = Once>
                    {
                    }
                    impl<Join, On> SelectableExpression<JoinOn<Join, On>> for id
                        where id: SelectableExpression<Join> + AppearsOnTable<JoinOn<Join, On>>
                    {
                    }
                    impl<From> SelectableExpression<SelectStatement<From>> for id
                        where id: SelectableExpression<From> + AppearsOnTable<SelectStatement<From>>
                    {
                    }
                    impl ::expression::NonAggregate for id {}
                    impl ::query_source::Column for id {
                        type Table = table;
                        fn name() -> &'static str {
                            "id"
                        }
                    }
                    impl <T> ::EqAll<T> for id where
                     T: ::expression::AsExpression<Uuid>,
                     ::expression::helper_types::Eq<id,
                                                    T>: ::Expression<SqlType =
                     ::types::Bool> {
                        type
                        Output
                        =
                        ::expression::helper_types::Eq<Self, T>;
                        fn eq_all(self, rhs: T) -> Self::Output {
                            ::expression::operators::Eq::new(self,
                                                             rhs.as_expression())
                        }
                    }
                    #[doc = r" The `email` column of the `users` table."]
                    #[doc = r""]
                    #[doc = r" Its SQL type is `Varchar`."]
                    #[doc = r""]
                    #[doc = r" (Automatically generated by Diesel.)"]
                    #[allow(non_camel_case_types, dead_code)]
                    #[rustc_copy_clone_marker]
                    pub struct email;
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    #[allow(non_camel_case_types, dead_code)]
                    impl ::std::fmt::Debug for email {
                        fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                            match *self {
                                email => {
                                    let mut builder = __arg_0.debug_tuple("email");
                                    builder.finish()
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    #[allow(non_camel_case_types, dead_code)]
                    impl ::std::clone::Clone for email {
                        #[inline]
                        fn clone(&self) -> email {
                            {
                                *self
                            }
                        }
                    }
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    #[allow(non_camel_case_types, dead_code)]
                    impl ::std::marker::Copy for email {}
                    impl ::expression::Expression for email {
                        type SqlType = Varchar;
                    }
                    impl<DB> ::query_builder::QueryFragment<DB> for email
                        where DB: ::backend::Backend,
                              <table as QuerySource>::FromClause: QueryFragment<DB>
                    {
                        fn walk_ast(&self,
                                    mut out: ::query_builder::AstPass<DB>)
                                    -> ::result::QueryResult<()> {
                            table.from_clause().walk_ast(out.reborrow())?;
                            out.push_sql(".");
                            out.push_identifier("email")
                        }
                    }
                    impl ::query_builder::QueryId for email {
                        type QueryId = Self;
                        fn has_static_query_id() -> bool {
                            true
                        }
                    }
                    impl SelectableExpression<table> for email {}
                    impl<QS> AppearsOnTable<QS> for email
                        where QS: AppearsInFromClause<table, Count = Once>
                    {
                    }
                    impl<Left, Right> SelectableExpression<Join<Left, Right, LeftOuter>> for email
                        where email: AppearsOnTable<Join<Left, Right, LeftOuter>>,
                              Left: AppearsInFromClause<table, Count = Once>,
                              Right: AppearsInFromClause<table, Count = Never>
                    {
                    }
                    impl<Left, Right> SelectableExpression<Join<Left, Right, Inner>> for email
                        where email: AppearsOnTable<Join<Left, Right, Inner>>,
                              Join<Left, Right, Inner>: AppearsInFromClause<table, Count = Once>
                    {
                    }
                    impl<Join, On> SelectableExpression<JoinOn<Join, On>> for email
                        where email: SelectableExpression<Join> + AppearsOnTable<JoinOn<Join, On>>
                    {
                    }
                    impl <From> SelectableExpression<SelectStatement<From>>
                     for email where email: SelectableExpression<From> +
                     AppearsOnTable<SelectStatement<From>> {
                    }
                    impl ::expression::NonAggregate for email {}
                    impl ::query_source::Column for email {
                        type Table = table;
                        fn name() -> &'static str {
                            "email"
                        }
                    }
                    impl <T> ::EqAll<T> for email where
                     T: ::expression::AsExpression<Varchar>,
                     ::expression::helper_types::Eq<email,
                                                    T>: ::Expression<SqlType =
                     ::types::Bool> {
                        type
                        Output
                        =
                        ::expression::helper_types::Eq<Self, T>;
                        fn eq_all(self, rhs: T) -> Self::Output {
                            ::expression::operators::Eq::new(self,
                                                             rhs.as_expression())
                        }
                    }
                    #[doc = r" The `password` column of the `users` table."]
                    #[doc = r""]
                    #[doc = r" Its SQL type is `Varchar`."]
                    #[doc = r""]
                    #[doc = r" (Automatically generated by Diesel.)"]
                    #[allow(non_camel_case_types, dead_code)]
                    #[rustc_copy_clone_marker]
                    pub struct password;
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    #[allow(non_camel_case_types, dead_code)]
                    impl ::std::fmt::Debug for password {
                        fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                            match *self {
                                password => {
                                    let mut builder = __arg_0.debug_tuple("password");
                                    builder.finish()
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    #[allow(non_camel_case_types, dead_code)]
                    impl ::std::clone::Clone for password {
                        #[inline]
                        fn clone(&self) -> password {
                            {
                                *self
                            }
                        }
                    }
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    #[allow(non_camel_case_types, dead_code)]
                    impl ::std::marker::Copy for password {}
                    impl ::expression::Expression for password {
                        type SqlType = Varchar;
                    }
                    impl<DB> ::query_builder::QueryFragment<DB> for password
                        where DB: ::backend::Backend,
                              <table as QuerySource>::FromClause: QueryFragment<DB>
                    {
                        fn walk_ast(&self,
                                    mut out: ::query_builder::AstPass<DB>)
                                    -> ::result::QueryResult<()> {
                            table.from_clause().walk_ast(out.reborrow())?;
                            out.push_sql(".");
                            out.push_identifier("password")
                        }
                    }
                    impl ::query_builder::QueryId for password {
                        type QueryId = Self;
                        fn has_static_query_id() -> bool {
                            true
                        }
                    }
                    impl SelectableExpression<table> for password {}
                    impl<QS> AppearsOnTable<QS> for password
                        where QS: AppearsInFromClause<table, Count = Once>
                    {
                    }
                    impl<Left, Right> SelectableExpression<Join<Left, Right, LeftOuter>> for password
                        where password: AppearsOnTable<Join<Left, Right, LeftOuter>>,
                              Left: AppearsInFromClause<table, Count = Once>,
                              Right: AppearsInFromClause<table, Count = Never>
                    {
                    }
                    impl<Left, Right> SelectableExpression<Join<Left, Right, Inner>> for password
                        where password: AppearsOnTable<Join<Left, Right, Inner>>,
                              Join<Left, Right, Inner>: AppearsInFromClause<table, Count = Once>
                    {
                    }
                    impl <Join, On> SelectableExpression<JoinOn<Join, On>> for
                     password where password: SelectableExpression<Join> +
                     AppearsOnTable<JoinOn<Join, On>> {
                    }
                    impl <From> SelectableExpression<SelectStatement<From>>
                     for password where password: SelectableExpression<From> +
                     AppearsOnTable<SelectStatement<From>> {
                    }
                    impl ::expression::NonAggregate for password {}
                    impl ::query_source::Column for password {
                        type Table = table;
                        fn name() -> &'static str {
                            "password"
                        }
                    }
                    impl <T> ::EqAll<T> for password where
                     T: ::expression::AsExpression<Varchar>,
                     ::expression::helper_types::Eq<password,
                                                    T>: ::Expression<SqlType =
                     ::types::Bool> {
                        type
                        Output
                        =
                        ::expression::helper_types::Eq<Self, T>;
                        fn eq_all(self, rhs: T) -> Self::Output {
                            ::expression::operators::Eq::new(self,
                                                             rhs.as_expression())
                        }
                    }
                }
            }
        }
        pub use self::infer_users::*;
        impl ::JoinTo<users::table> for scope_permissions::table {
            type FromClause = users::table;
            type
            OnClause
            =
            ::expression::helper_types::Eq<::expression::nullable::Nullable<scope_permissions::user_id>,
                                           ::expression::nullable::Nullable<<users::table
                                                                            as
                                                                            ::query_source::Table>::PrimaryKey>>;
            fn join_target(rhs: users::table) -> (Self::FromClause, Self::OnClause) {
                use {ExpressionMethods, NullableExpressionMethods};
                (rhs,
                 scope_permissions::user_id.nullable()
                     .eq(<users::table as ::query_source::Table>::primary_key(&users::table)
                             .nullable()))
            }
        }
        impl ::JoinTo<scope_permissions::table> for users::table {
            type FromClause = scope_permissions::table;
            type
            OnClause
            =
            ::expression::helper_types::Eq<::expression::nullable::Nullable<scope_permissions::user_id>,
                                           ::expression::nullable::Nullable<<users::table
                                                                            as
                                                                            ::query_source::Table>::PrimaryKey>>;
            fn join_target(rhs: scope_permissions::table) -> (Self::FromClause, Self::OnClause) {
                use {ExpressionMethods, NullableExpressionMethods};
                (rhs,
                 scope_permissions::user_id.nullable()
                     .eq(<users::table as ::query_source::Table>::primary_key(&users::table)
                             .nullable()))
            }
        }
        impl ::JoinTo<scopes::table> for scope_permissions::table {
            type FromClause = scopes::table;
            type
            OnClause
            =
            ::expression::helper_types::Eq<::expression::nullable::Nullable<scope_permissions::scope_id>,
                                           ::expression::nullable::Nullable<<scopes::table
                                                                            as
                                                                            ::query_source::Table>::PrimaryKey>>;
            fn join_target(rhs: scopes::table) -> (Self::FromClause, Self::OnClause) {
                use {ExpressionMethods, NullableExpressionMethods};
                (rhs,
                 scope_permissions::scope_id.nullable()
                     .eq(<scopes::table as ::query_source::Table>::primary_key(&scopes::table)
                             .nullable()))
            }
        }
        impl ::JoinTo<scope_permissions::table> for scopes::table {
            type FromClause = scope_permissions::table;
            type
            OnClause
            =
            ::expression::helper_types::Eq<::expression::nullable::Nullable<scope_permissions::scope_id>,
                                           ::expression::nullable::Nullable<<scopes::table
                                                                            as
                                                                            ::query_source::Table>::PrimaryKey>>;
            fn join_target(rhs: scope_permissions::table) -> (Self::FromClause, Self::OnClause) {
                use {ExpressionMethods, NullableExpressionMethods};
                (rhs,
                 scope_permissions::scope_id.nullable()
                     .eq(<scopes::table as ::query_source::Table>::primary_key(&scopes::table)
                             .nullable()))
            }
        }
        impl ::JoinTo<users::table> for scope_transactions::table {
            type FromClause = users::table;
            type
            OnClause
            =
            ::expression::helper_types::Eq<::expression::nullable::Nullable<scope_transactions::user_id>,
                                           ::expression::nullable::Nullable<<users::table
                                                                            as
                                                                            ::query_source::Table>::PrimaryKey>>;
            fn join_target(rhs: users::table) -> (Self::FromClause, Self::OnClause) {
                use {ExpressionMethods, NullableExpressionMethods};
                (rhs,
                 scope_transactions::user_id.nullable()
                     .eq(<users::table as ::query_source::Table>::primary_key(&users::table)
                             .nullable()))
            }
        }
        impl ::JoinTo<scope_transactions::table> for users::table {
            type FromClause = scope_transactions::table;
            type
            OnClause
            =
            ::expression::helper_types::Eq<::expression::nullable::Nullable<scope_transactions::user_id>,
                                           ::expression::nullable::Nullable<<users::table
                                                                            as
                                                                            ::query_source::Table>::PrimaryKey>>;
            fn join_target(rhs: scope_transactions::table) -> (Self::FromClause, Self::OnClause) {
                use {ExpressionMethods, NullableExpressionMethods};
                (rhs,
                 scope_transactions::user_id.nullable()
                     .eq(<users::table as ::query_source::Table>::primary_key(&users::table)
                             .nullable()))
            }
        }
    }
    pub use self::__diesel_infer_schema::*;
}
mod models {
    pub mod user {
        use rocket::Outcome;
        use rocket::request::{self, FromRequest, Request};
        use diesel::prelude::*;
        use diesel::pg::types::sql_types::Uuid;
        use schema::users;
        use db;
        use rocket_contrib::UUID;
        pub struct User {
            pub id: Uuid,
            pub email: String,
            pub password: String,
        }
        const _IMPL_QUERYABLE_FOR_USER: () = {
            extern crate diesel;
            impl<__DB, __ST> diesel::Queryable<__ST, __DB> for User
                where __DB: diesel::backend::Backend + diesel::types::HasSqlType<__ST>,
                      (Uuid, String, String): diesel::types::FromSqlRow<__ST, __DB>
            {
                type Row = (Uuid, String, String);
                fn build((id, email, password): Self::Row) -> Self {
                    User {
                        id: id,
                        email: email,
                        password: password,
                    }
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for User {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                match *self {
                    User { id: ref __self_0_0,
                           email: ref __self_0_1,
                           password: ref __self_0_2 } => {
                        let mut builder = __arg_0.debug_struct("User");
                        let _ = builder.field("id", &&(*__self_0_0));
                        let _ = builder.field("email", &&(*__self_0_1));
                        let _ = builder.field("password", &&(*__self_0_2));
                        builder.finish()
                    }
                }
            }
        }
        #[table_name = "users"]
        pub struct NewUser {
            pub email: String,
            pub password: String,
        }
        impl <'insert, DB> ::insertable::Insertable<users::table, DB> for
         &'insert NewUser where DB: ::backend::Backend,
         (::insertable::ColumnInsertValue<users::email,
                                          ::expression::helper_types::AsExpr<&'insert String,
                                                                             users::email>>,
          ::insertable::ColumnInsertValue<users::password,
                                          ::expression::helper_types::AsExpr<&'insert String,
                                                                             users::password>>): ::insertable::InsertValues<DB>
         {
            type
            Values
            =
            (::insertable::ColumnInsertValue<users::email,
                                             ::expression::helper_types::AsExpr<&'insert String,
                                                                                users::email>>,
             ::insertable::ColumnInsertValue<users::password,
                                             ::expression::helper_types::AsExpr<&'insert String,
                                                                                users::password>>);
            #[allow(non_shorthand_field_patterns)]
            fn values(self) -> Self::Values {
                use ::expression::{AsExpression, Expression};
                use ::insertable::ColumnInsertValue;
                let NewUser { email: ref email, password: ref password } =
                    *self;
                (ColumnInsertValue::Expression(users::email,
                                               AsExpression::<<users::email as
                                                              Expression>::SqlType>::as_expression(email)),
                 ColumnInsertValue::Expression(users::password,
                                               AsExpression::<<users::password
                                                              as
                                                              Expression>::SqlType>::as_expression(password)))
            }
        }
        impl<'insert, Op> ::query_builder::insert_statement::IntoInsertStatement<users::table, Op>
            for
            &'insert NewUser {
            type InsertStatement = ::query_builder::insert_statement::InsertStatement<users::table,
                                                               Self,
                                                               Op>;
            fn into_insert_statement(self,
                                     target: users::table,
                                     operator: Op)
                                     -> Self::InsertStatement {
                ::query_builder::insert_statement::InsertStatement::no_returning_clause(target,
                                                                                        self,
                                                                                        operator)
            }
        }
        impl<'insert> ::query_builder::insert_statement::UndecoratedInsertRecord<users::table>
            for
            &'insert NewUser {
        }
        impl<'a, 'r> FromRequest<'a, 'r> for User {
            type Error = ();
            fn from_request(req: &'a Request<'r>) -> request::Outcome<User, ()> {
                use schema::users::dsl::*;
                let conn = match <db::PgSqlConn as FromRequest>::from_request(req) {
                    Outcome::Success(conn) => conn,
                    _ => return Outcome::Forward(()),
                };
                let user = req.cookies()
                    .get_private("user_id")
                    .and_then(|cookie| cookie.value().parse::<UUID>().ok())
                    .map(|user_id| users.find(*user_id).get_result(&*conn));
                let user = match user {
                    None => return Outcome::Forward(()),
                    Some(u) => u,
                };
                match user {
                    Err(_) => Outcome::Failure((::rocket::http::Status::NotFound, ())),
                    Ok(u) => Outcome::Success(u),
                }
            }
        }
    }
    pub enum Scope_roles {
        write,
        read,
    }
}
#[allow(unreachable_code)]
fn rocket_route_fn_index<'_b>(__req: &'_b ::rocket::Request,
                              __data: ::rocket::Data)
                              -> ::rocket::handler::Outcome<'_b> {
    let responder = index();
    ::rocket::handler::Outcome::from(__req, responder)
}
/// Rocket code generated static route information structure.
#[allow(non_upper_case_globals)]
#[rocket_route_info]
pub static static_rocket_route_info_for_index: ::rocket::StaticRouteInfo =
    ::rocket::StaticRouteInfo {
        method: ::rocket::http::Method::Get,
        path: "/",
        handler: rocket_route_fn_index,
        format: None,
        rank: None,
    };
#[rocket_route(static_rocket_route_info_for_index)]
fn index() -> Markup {
    {
        extern crate maud;
        let mut __maud_output = String::with_capacity(11u64 as usize);
        __maud_output.push_str("<p>Welcome</p>");
        maud::PreEscaped(__maud_output)
    }
}
#[allow(unreachable_code)]
fn rocket_route_fn_say_hello<'_b>(__req: &'_b ::rocket::Request,
                                  __data: ::rocket::Data)
                                  -> ::rocket::handler::Outcome<'_b> {
    #[allow(non_snake_case, unreachable_patterns)]
    let rocket_param_user_id: UUID = match match __req.get_param_str(0usize) {
              Some(s) => <UUID as ::rocket::request::FromParam>::from_param(s),
              None => return ::rocket::Outcome::Forward(__data),
          } {
        Ok(v) => v,
        Err(e) => {
            ::io::_print(::std::fmt::Arguments::new_v1(&["    => Failed to parse \'",
                                                         "\': ",
                                                         "\n"],
                                                       &match (&"user_id", &e) {
                                                            (__arg0,
                                                                 __arg1) =>
                                                                [::std::fmt::ArgumentV1::new(__arg0,
                                                                                             ::std::fmt::Display::fmt),
                                                                 ::std::fmt::ArgumentV1::new(__arg1,
                                                                                             ::std::fmt::Debug::fmt)],
                                                        }));
            return ::rocket::Outcome::Forward(__data);
        }
    };
    #[allow(non_snake_case, unreachable_patterns)]
    let rocket_param_conn: db::PgSqlConn =
        match ::rocket::request::FromRequest::from_request(__req) {
            ::rocket::Outcome::Success(v) => v,
            ::rocket::Outcome::Forward(_) => return ::rocket::Outcome::Forward(__data),
            ::rocket::Outcome::Failure((code, _)) => return ::rocket::Outcome::Failure(code),
        };
    let responder = say_hello(rocket_param_conn, rocket_param_user_id);
    ::rocket::handler::Outcome::from(__req, responder)
}
/// Rocket code generated static route information structure.
#[allow(non_upper_case_globals)]
#[rocket_route_info]
pub static static_rocket_route_info_for_say_hello: ::rocket::StaticRouteInfo =
    ::rocket::StaticRouteInfo {
        method: ::rocket::http::Method::Get,
        path: "/user/<user_id>",
        handler: rocket_route_fn_say_hello,
        format: None,
        rank: None,
    };
#[rocket_route(static_rocket_route_info_for_say_hello)]
fn say_hello(conn: db::PgSqlConn, user_id: UUID) -> Markup {
    use schema::users::dsl::*;
    use models::user::User;
    let user: User = users.find(*user_id).get_result(&*conn).expect("User not found");
    {
        extern crate maud;
        let mut __maud_output = String::with_capacity(11u64 as usize);
        __maud_output.push_str("<p>Welcome</p>");
        maud::PreEscaped(__maud_output)
    }
}
fn main() {
    let conn = db::establish_connection();
    rocket::ignite().mount("/",
                           <[_]>::into_vec(box
                                               [::rocket::Route::from(&static_rocket_route_info_for_index),
                                                ::rocket::Route::from(&static_rocket_route_info_for_say_hello)])).manage(conn).launch();
}
